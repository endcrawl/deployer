#!/bin/sh

usage() { echo "usage: ${0##*/} [-x] [-k path/to/ssh/key] [-u user] [-g group] <unit> <git-url> [<branch>]"; }

main()
{
  DEPLOYER_INPLACE=${DEPLOYER_INPLACE:-0}

  while [ $# -gt 0 ]; do
    case "$1" in
         -x) DEPLOYER_INPLACE=1    ; shift ;;
         -k) DEPLOYER_SSH_KEY="$2" ; shift ; shift ;;
         -u) DEPLOYER_USER="$2"    ; shift ; shift ;;
         -g) DEPLOYER_GROUP="$2"   ; shift ; shift ;;
         -h) usage ; exit 0 ;;
         -*) barf "unknown option: $1" ;;
          *) break ;;
    esac
  done

  if [ $# -lt 2 ]; then
    usage 1>&2
    exit 100
  fi

  unit="$1" ; shift
  git_url="$1" ; shift
  branch="${1:-master}"

  test -z "$unit"                 && barf "missing unit"
  test "$unit" != "${unit##*.}"   && barf "invalid unit: $unit"
  test "$unit" != "${unit##*/}"   && barf "invalid unit: $unit"
  test -z "$DEPLOYER_DEPLOY_ROOT" && barf "missing environment variable: DEPLOYER_DEPLOY_ROOT"
  test -d "$DEPLOYER_DEPLOY_ROOT" || barf "deploy root directory missing: $DEPLOYER_DEPLOY_ROOT"
  test -z "$DEPLOYER_QUEUE"       && barf "missing environment variable: DEPLOYER_QUEUE"
  test -d "$DEPLOYER_QUEUE"       || barf "deploy root directory missing: $DEPLOYER_QUEUE"
  test -z "$DEPLOYER_DATA_DIR"    && barf "missing environment variable: DEPLOYER_DATA_DIR"
  test -d "$DEPLOYER_DATA_DIR"    || barf "deploy data directory missing: $DEPLOYER_DATA_DIR"
  test -z "$DEPLOYER_USER"        || DEPLOYER_GROUP=${DEPLOYER_GROUP:-`id -ng "$DEPLOYER_USER"`} || barf "gid error for $DEPLOYER_USER"

  # In privileged mode, some per-unit settings are required.

  if [ `id -u` -eq 0 ]; then
    test -z "$DEPLOYER_USER"  && barf "missing required per-unit setting in privileged mode: DEPLOYER_USER"
    test -z "$DEPLOYER_GROUP" && barf "missing required per-unit setting in privileged mode: DEPLOYER_GROUP"
  fi

  # Create a per-unit directory for settings.

  safe mkdir -p "${DEPLOYER_DATA_DIR}/${unit}"

  # Store per-unit settings.

  test -z "$DEPLOYER_SSH_KEY" || safe printf "%s" "$DEPLOYER_SSH_KEY" > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_SSH_KEY"
  test -z "$DEPLOYER_USER"    || safe printf "%s" "$DEPLOYER_USER"    > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_USER"
  test -z "$DEPLOYER_GROUP"   || safe printf "%s" "$DEPLOYER_GROUP"   > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_GROUP"
                                 safe printf "%s" "$unit"             > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_UNIT"

  # Create a per-unit directory for incoming deployer job requests.

  safe mkdir -p "${DEPLOYER_QUEUE}/req/${unit}"

  # Create foo.a/ and foo.b/ directories (or just foo.x/ if in-place) under the deploy root.

  if [ "$DEPLOYER_INPLACE" -gt 0 ]; then
    suffixes="x"
    target_default="${unit}.x"
  else
    suffixes="a b"
    target_default="${unit}.a"
  fi

  # TODO handle privsep mode.

  for suffix in $suffixes; do
    export GIT_WORK_TREE="$DEPLOYER_DEPLOY_ROOT/${unit}.${suffix}"
    export GIT_DIR="${GIT_WORK_TREE}/.git"
    safe mkdir -p "$GIT_WORK_TREE"
    test -d "$GIT_DIR" || {
      safe git init --shared=group
      safe git remote add origin "$git_url"
      safe git fetch origin
      safe git checkout -f "$branch"
    }
  done

  # Ensure one of foo.a/ and foo.b/ is active (has the foo symlink pointing to it).

  test -e "$DEPLOYER_DEPLOY_ROOT/${unit}" || safe ln -s "$target_default" "$DEPLOYER_DEPLOY_ROOT/${unit}"

  return 0
}

. shellsafe || { echo "error sourcing shellsafe." 1>&2 ; exit 100 ; }
main "$@"
exit $?

