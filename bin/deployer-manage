#!/bin/sh

usage() { echo "usage: ${0##*/} [-x] [-k path/to/ssh/key] [-u user] [-g group] <unit> <git-url> [<branch>]"; }

main()
{
  DEPLOYER_INPLACE=${DEPLOYER_INPLACE:-0}

  while [ $# -gt 0 ]; do
    case "$1" in
         -x) DEPLOYER_INPLACE=1    ; shift ;;
         -k) DEPLOYER_SSH_KEY="$2" ; shift ; shift ;;
         -u) DEPLOYER_USER="$2"    ; shift ; shift ;;
         -g) DEPLOYER_GROUP="$2"   ; shift ; shift ;;
         -h) usage ; exit 0 ;;
         -*) barf "unknown option: $1" ;;
          *) break ;;
    esac
  done
  export DEPLOYER_INPLACE
  export DEPLOYER_SSH_KEY
  export DEPLOYER_USER
  export DEPLOYER_GROUP

  if [ $# -lt 2 ]; then
    usage 1>&2
    exit 100
  fi

  unit="$1" ; shift
  git_url="$1" ; shift
  branch="${1:-master}"

  test -z "$unit"                 && barf "missing unit"
  test "$unit" != "${unit##*.}"   && barf "invalid unit: $unit"
  test "$unit" != "${unit##*/}"   && barf "invalid unit: $unit"
  test -z "$DEPLOYER_DEPLOY_ROOT" && barf "missing environment variable: DEPLOYER_DEPLOY_ROOT"
  test -d "$DEPLOYER_DEPLOY_ROOT" || barf "deploy root directory missing: $DEPLOYER_DEPLOY_ROOT"
  test -z "$DEPLOYER_QUEUE"       && barf "missing environment variable: DEPLOYER_QUEUE"
  test -d "$DEPLOYER_QUEUE"       || barf "deploy root directory missing: $DEPLOYER_QUEUE"
  test -z "$DEPLOYER_DATA_DIR"    && barf "missing environment variable: DEPLOYER_DATA_DIR"
  test -d "$DEPLOYER_DATA_DIR"    || barf "deploy data directory missing: $DEPLOYER_DATA_DIR"
  test -z "$DEPLOYER_USER"        || DEPLOYER_GROUP=${DEPLOYER_GROUP:-`id -ng "$DEPLOYER_USER"`} || barf "gid error for $DEPLOYER_USER"

  # In privileged mode, some per-unit settings are required.

  if [ `id -u` -eq 0 ]; then
    test -z "$DEPLOYER_USER"  && barf "missing required per-unit setting in privileged mode: DEPLOYER_USER"
    test -z "$DEPLOYER_GROUP" && barf "missing required per-unit setting in privileged mode: DEPLOYER_GROUP"
  fi

  # Load any ssh key and make it accessible.

  if [ -n "$DEPLOYER_SSH_KEY" ]; then
    test "${DEPLOYER_SSH_KEY#/}" != "$DEPLOYER_SSH_KEY" || barf "non-absolute path for DEPLOYER_SSH_KEY: $DEPLOYER_SSH_KEY"
    test -n "$SSH_AUTH_SOCK" || safe exec ssh-agent "$0" "$unit" "$git_url" "$branch"
    safe ssh-add "$DEPLOYER_SSH_KEY"
    if [ `id -u` -eq 0 ]; then
      safe chmod g+rwx "$SSH_AUTH_SOCK"
      safe chgrp "$DEPLOYER_GROUP" "$SSH_AUTH_SOCK"
    fi
  fi

  # Create a per-unit directory for settings.

  safe mkdir -p "${DEPLOYER_DATA_DIR}/${unit}"

  # Store per-unit settings.

  test -z "$DEPLOYER_SSH_KEY" || safe printf "%s" "$DEPLOYER_SSH_KEY" > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_SSH_KEY"
  test -z "$DEPLOYER_USER"    || safe printf "%s" "$DEPLOYER_USER"    > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_USER"
  test -z "$DEPLOYER_GROUP"   || safe printf "%s" "$DEPLOYER_GROUP"   > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_GROUP"
                                 safe printf "%s" "$unit"             > "${DEPLOYER_DATA_DIR}/${unit}/DEPLOYER_UNIT"

  # Create a per-unit directory for incoming deployer job requests.

  safe mkdir -p "${DEPLOYER_QUEUE}/req/${unit}"

  # Create foo.a/ and foo.b/ directories (or just foo.x/ if in-place) under the deploy root.

  if [ "$DEPLOYER_INPLACE" -gt 0 ]; then
    suffixes="x"
    target_default="${unit}.x"
  else
    suffixes="a b"
    target_default="${unit}.a"
  fi

  for suffix in $suffixes; do
    export GIT_WORK_TREE="$DEPLOYER_DEPLOY_ROOT/${unit}.${suffix}"
    export GIT_DIR="${GIT_WORK_TREE}/.git"
    safe mkdir -p "$GIT_WORK_TREE"
    if [ `id -u` -eq 0 ]; then
      safe chown "${DEPLOYER_USER}:${DEPLOYER_GROUP}" "$GIT_WORK_TREE"
      safe setuidgid -s "$DEPLOYER_USER" env HOME=/nonexistent deployer-checkout "$git_url" "$branch"
    else
      safe deployer-checkout "$git_url" "$branch"
    fi
  done

  # Ensure one of foo.a/ and foo.b/ is active (has the foo symlink pointing to it).

  test -e "$DEPLOYER_DEPLOY_ROOT/${unit}" || safe ln -s "$target_default" "$DEPLOYER_DEPLOY_ROOT/${unit}"

  return 0
}

. shellsafe || { echo "error sourcing shellsafe." 1>&2 ; exit 100 ; }
main "$@"
exit $?

