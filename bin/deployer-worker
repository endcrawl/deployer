#!/bin/sh

main()
{
  # Parse data out of the job file name.

  jobname="$FSQ_JOB"
  unit="${jobname%%.*}"      ; jobname="${jobname#*.}"
  revision="${jobname%%.*}"  ; jobname="${jobname#*.}"
  jobdate="${jobname%%.*}"   ; jobname="${jobname#*.}"
  jobtime="${jobname%%.*}"   ; jobname="${jobname#*.}"
  jobrandom="${jobname%%.*}" ; jobname="${jobname#*.}"

  [ -z "$unit"     ] && barf "cannot parse unit from jobfile: $FSQ_JOB" 100
  [ -z "$revision" ] && barf "cannot parse revision from jobfile: $FSQ_JOB" 100

  # Only one deploy is allowed to run at a time for a given unit.
  # Grab the per-unit lock, or fail immediately if already locked.
  # On lock success, record it with an env var and re-execute self.

  export LOCKED_UNIT

  if [ -z "$LOCKED_UNIT" ]; then
    lockfile="$DEPLOYER_LOCK_DIR"/unit/"$unit".lock
    LOCKED_UNIT="$lockfile" safe exec setlock -n "$lockfile" "$0" "$@"
  else
    shout "locked: $LOCKED_UNIT"
  fi

  # Got all necessary locks. Invoke the deployer.

  deployer "$unit" "$revision" "$@"
  rc=$?

  # On successful deployment, pull the bouncer's trigger.

  [ "$rc" -eq 0 -a -n "$DEPLOYER_BOUNCER_TRIGGER" ] && trigger-pull "$DEPLOYER_BOUNCER_TRIGGER" >/dev/null 2>&1

  # Ignore an exit code of 99 = there was nothing to deploy.

  [ $rc -eq 99 ] && rc=0
  return $rc
}

. shellsafe || { echo "error sourcing shellsafe." 1>&2 ; exit 100 ; }
main "$@"
exit $?

