#!/bin/sh

usage() { echo "usage: ${0##*/} <unit> <revision> [<program>]"; }

main()
{
  if [ $# -lt 2 ]; then
    usage 1>&2
    exit 100
  fi

  unit="$1"        ; shift
  revision="$1"    ; shift

  # Validate unit and revision against unsafe path chars.

  for a in "$unit" "$revision"; do
    test -z "$a"            && barf "missing unit or revision"
    test "$a" != "${a##*.}" && barf "invalid unit or revision: $a"
    test "$a" != "${a##*/}" && barf "invalid unit or revision: $a"
  done

  # Validate deploy root.

  test -z "$DEPLOYER_DEPLOY_ROOT" && barf "missing environment variable: DEPLOYER_DEPLOY_ROOT"
  test -d "$DEPLOYER_DEPLOY_ROOT" || barf "deploy root directory missing: $DEPLOYER_DEPLOY_ROOT"

  deploy_root="$DEPLOYER_DEPLOY_ROOT"

  # Require existing a & b directories.

  path_a="${deploy_root}/${unit}.a"
  path_b="${deploy_root}/${unit}.b"

  test -d "$path_a" || barf "missing git checkout: $path_a"
  test -d "$path_b" || barf "missing git checkout: $path_b"

  # Determine the currently active checkout for this unit.
  # Create the initial symlink if necessary.

  path_symlink="${deploy_root}/${unit}"

  test -L "$path_symlink" || safe ln -s "${unit}.a" "$path_symlink"

  if [ -L "$path_symlink" ]; then
    target_old=`readlink "$path_symlink"`
  elif [ -e "$path_symlink" ]; then
    barf "non-symlink at: $path_symlink"
  else
    barf "failed to find symlink at: $path_symlink"
  fi

  # Determine the currently inactive checkout for this unit.

  if [ "$target_old" = "${unit}.a" ]; then
    target_new="${unit}.b"
  else
    target_new="${unit}.a"
  fi

  path_old="${deploy_root}/${target_old}"
  path_new="${deploy_root}/${target_new}"

  # Determine the currently active revision.

  export GIT_WORK_TREE="$path_old"
  export GIT_DIR="${path_old}/.git"
  revision_old=`safe git rev-parse HEAD`
  test -n "$revision_old" || barf "error getting current revision for: ${target_old}"

  # Update the inactive checkout with git.
  # Exit with special status if it would be identical to the active checkout.

  export GIT_WORK_TREE="$path_new"
  export GIT_DIR="${path_new}/.git"
  safe git fetch
  git diff --exit-code "$revision_old" origin/"$revision" >/dev/null
  case $? in
    0)
      log 2 "no changes for: ${target_new} ${revision}"
      exit 99
      ;;
    1)
      log 2 "applying changes to inactive checkout: ${target_new}"
      # XXX workaround: git-stash doesn't honor GIT_WORK_TREE / GIT_DIR as of 1.9.1
      ( safe cd "$GIT_WORK_TREE" && git stash )
      safe git checkout --detach origin/"$revision"
      ;;
    *)
      barf "git-diff failed with exit code: $?"
      ;;
  esac

  # Run the tail program (typically just `make`) to do post-update tasks.
  # Touch a file to indicate that a new deployment happened.

  (
    safe cd "$path_new"
    test $# -eq 0 || safe "$@"
    safe touch .deployed
  )
  rc="$?" ; if [ "$rc" -ne 0 ]; then return "$rc"; fi

  # Create the new symlink under the tmp/ dir.

  safe ln -s "$target_new" "${deploy_root}/tmp/${unit}"

  # Atomically move the new symlink into place.

  (
    safe cd "${deploy_root}/tmp"
    safe mv "$unit" ..
  )
  rc="$?" ; if [ "$rc" -ne 0 ]; then return "$rc"; fi

  log 2 "switched active checkout to: ${target_new}"

  return 0
}

. deployer-shlib || { echo "error sourcing deployer-shlib." 1>&2 ; exit 100 ; }
main "$@"
exit $?

